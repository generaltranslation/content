---
title: "The Hidden Problem with Translating Across Multiple Branches"
summary: "When your CI/CD pipeline translates content on every push, multi-branch workflows can silently corrupt your translation files. Here's why it happens and how to fix it."
date: 2025-02-17
authors: [default]
tags: ['guide', 'branching', 'CI/CD', 'preview deployments', 'internationalization', 'i18n', 'gtx-cli']
images: ['/static/blogs/branching.png']
layout: PostLayout
---

## A typical translation pipeline

Let's say you're building an app that needs to support multiple languages. A common approach is to keep a set of JSON translation files — one per locale — and translate new content as part of your CI/CD pipeline.

For example, you might have a step in your pipeline that reads your source locale file and translates any new or changed entries using an AI model:

```bash
curl -X POST https://api.openai.com/v1/chat/completions \
  -H "Authorization: Bearer $OPENAI_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gpt-4o",
    "messages": [
      {
        "role": "system",
        "content": "Translate the following JSON values from English to Spanish. Return only valid JSON."
      },
      {
        "role": "user",
        "content": "{\"welcome\": \"Welcome to our app\", \"pricing_title\": \"Simple, transparent pricing\"}"
      }
    ]
  }'
```

The output gets written to something like `locales/es.json`, committed, and deployed. Your source JSON file is the single source of truth, and each `translate` step just makes sure the other locales are up to date.

This works perfectly — as long as you're only deploying from one branch.

## What goes wrong with multiple branches

Now imagine your team has two branches in flight:

- **`main`** — your production branch, fully translated
- **`feature/new-pricing`** — a feature branch with new copy, deployed to a preview environment

Both branches run the translate step in CI on every push. Both write their results to the same translation files. Here's where things break down.

### Translations overwrite each other

When `feature/new-pricing` runs, it translates its version of the content and commits the result. When `main` runs next, it does the same. If both branches modify `locales/es.json`, **the last branch to deploy wins**.

Your preview deployment's translations can silently end up in production, and vice versa. There's no error — just the wrong content served to users.

### Diffs cause retranslation churn

Most translation pipelines compare current content against the previous version to figure out what's new. When two branches diverge significantly, each translate step sees a large diff relative to whatever the other branch last committed.

Content that exists on `main` but not on `feature/new-pricing` looks deleted. Content on the feature branch that doesn't exist on `main` looks brand new. **Every time either branch translates, it undoes the other branch's work.**

The result: entries that aren't shared between the two branches get retranslated on every push. You burn through API credits, and your translations flicker between two states depending on which pipeline ran last.

### It scales badly

With two branches, translations flip-flop. With three or four active branches, it's a free-for-all. Your translation state becomes essentially random — determined by whichever CI job finished most recently.

## The root cause

The fundamental issue is that **all branches share the same translation files with no isolation**. Every translate step assumes it's the only one writing to those files. The moment you have concurrent branches, that assumption breaks.

You could try to solve this with git merge strategies or locking mechanisms, but that adds complexity and fragility. What you really need is branch-aware translation tracking — translations that are automatically scoped to the branch they were created on.

## The fix: branch-aware translations with GT

[General Translation](https://generaltranslation.com) solves this natively. Instead of managing translation files and API calls yourself, you use the GT CLI to translate your content — and with one flag, translations are automatically isolated per branch:

```bash
npx gtx-cli translate --enable-branching
```

When branching is enabled, the CLI:

1. **Detects your current git branch** automatically
2. **Isolates translations per branch** — feature branch translations never touch production
3. **Inherits existing translations** — new branches start with all translations from `main`, so you only translate new or changed content
4. **Merges translations on merge** — when your feature branch merges into `main`, the translations come with it

No overwrites. No churn. No wasted API calls.

### Setting it up

Add the flag to your CI/CD translate command:

```bash
npx gtx-cli translate --enable-branching
```

Or configure it permanently in your `gt.config.json`:

```json title="gt.config.json"
{
  "branchOptions": {
    "enabled": true
  }
}
```

If your CI environment doesn't have git info available, you can specify the branch manually:

```bash
npx gtx-cli translate --enable-branching --branch my-feature-branch
```

## When does this matter?

**You'll hit this problem if:**

- Multiple developers push to different branches
- You have preview or staging deployments that trigger translations
- Your CI/CD pipeline translates on every push or PR

**You're probably fine if:**

- You only translate on merge to `main`
- You're working solo on a single branch

## The takeaway

If you're running translations in CI/CD across multiple branches, shared translation state is a ticking time bomb. Branches need isolated translations, and those translations need to merge cleanly when branches merge.

GT handles this out of the box with a single flag. No file locking, no merge conflicts, no wasted retranslation.

```bash
npx gtx-cli translate --enable-branching
```

For full details, see the [branching documentation](https://generaltranslation.com/docs/cli/branching).
