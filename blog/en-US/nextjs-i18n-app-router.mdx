---
title: How to internationalize a Next.js App Router application
summary: The standard i18n workflow makes you maintain two parallel systems. There's a better way.
date: 2026-02-17
authors: [default]
tags: ['guide', 'internationalization', 'nextjs', 'i18n', 'gt-next', 'app-router', 'tutorial']
layout: PostLayout
---

Internationalization in JavaScript has settled into a convention: extract every user-facing string into a JSON file, assign it a key, and reference that key in your components. `t('home.hero.title')` instead of the text itself. Your UI lives in one place, your content lives in another, and a layer of indirection connects them.

This works. Thousands of apps ship this way. But it's not a great developer experience.

The key-based model means reading `t('checkout.summary.total')` in a code review tells you nothing — you have to open a JSON file to see what changed. Keys have to be invented, namespaced, and kept in sync. Stale translations accumulate because nobody knows which keys are still in use. The problem is widespread enough that entire categories of tooling exist just to manage it: IDE extensions that auto-suggest keys, type generators that validate them, linters that flag unused ones. These tools are solving a problem the paradigm created.

The core issue is that content gets separated from where it's used. A component that renders a heading, a paragraph, and a button has its *structure* in JSX and its *words* in a JSON file three directories away. The two systems have to stay in sync, and they inevitably drift.

What if the library worked the other way around — adapting to your code instead of asking you to restructure it?

## The `<T>` component

Here's what it looks like to internationalize a component without translation keys:

```tsx
import { T } from 'gt-next';

function Hero() {
  return (
    <T>
      <h1>Ship your product worldwide</h1>
      <p>Reach every market without rewriting your app.</p>
    </T>
  );
}
```

Wrap your JSX in [`<T>`](https://generaltranslation.com/docs/next/api/components/t). The English text stays right where you wrote it. When a user visits in Spanish or Japanese, the content inside `<T>` is translated — including nested HTML structure, attributes, and formatting.

No keys. No JSON files. No cross-referencing. The source of truth is your code.

### Dynamic content

When a component renders dynamic values — a user's name, a count, a price — mark them with [`<Var>`](https://generaltranslation.com/docs/next/api/components/var) so they're inserted as-is rather than translated:

```tsx
import { T, Var } from 'gt-next';

function WelcomeBanner({ user }) {
  return (
    <T>
      <h1>Welcome back, <Var>{user.name}</Var></h1>
      <p>You have <Var>{user.notifications}</Var> new notifications.</p>
    </T>
  );
}
```

For locale-aware formatting — numbers, currencies, dates — there are dedicated components like [`<Num>`](https://generaltranslation.com/docs/next/api/components/num) and [`<Currency>`](https://generaltranslation.com/docs/next/api/components/currency) that format values according to the user's locale (e.g., `1,234.56` in English vs `1.234,56` in German).

### Translating strings

Not everything is JSX. For attributes, placeholders, and `aria-label` values, there's the [`useGT`](https://generaltranslation.com/docs/next/api/strings/use-gt) hook:

```tsx
import { useGT } from 'gt-next';

function SearchBar() {
  const gt = useGT();

  return (
    <input
      placeholder={gt('Search for products...')}
      aria-label={gt('Product search input')}
    />
  );
}
```

For async contexts like server components, [`getGT`](https://generaltranslation.com/docs/next/api/strings/get-gt) does the same thing.

## Setting up gt-next

The syntax above comes from [gt-next](https://generaltranslation.com/docs/next), an open-source i18n library for Next.js. Here's how to set it up.

### Install

```bash copy
npm i gt-next
npm i -D gtx-cli
```

### Configure your Next.js config

[`withGTConfig`](https://generaltranslation.com/docs/next/api/config/with-gt-config) wraps your Next.js config and sets up the translation pipeline, including a compiler plugin that processes your `<T>` components at build time:

```ts title="next.config.ts" copy
import { withGTConfig } from 'gt-next/config';

const nextConfig = {
  // your existing Next.js config
};

export default withGTConfig(nextConfig);
```

### Set your locales

Create a [`gt.config.json`](https://generaltranslation.com/docs/cli/reference/config) in your project root:

```json title="gt.config.json" copy
{
  "defaultLocale": "en",
  "locales": ["es", "fr", "de", "ja"]
}
```

### Add `GTProvider`

[`GTProvider`](https://generaltranslation.com/docs/next/api/components/gtprovider) supplies translation data to client components. Add it to your root layout:

```tsx title="app/layout.tsx" copy
import { GTProvider } from 'gt-next';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <GTProvider>
          {children}
        </GTProvider>
      </body>
    </html>
  );
}
```

### Environment variables

For development, add your API credentials to `.env.local`:

```bash title=".env.local" copy
GT_API_KEY="gtx-dev-your-dev-key"
GT_PROJECT_ID="your-project-id"
```

Get free keys at [dash.generaltranslation.com](https://dash.generaltranslation.com/signup), or run `npx gtx-cli auth`.

Dev keys (prefixed `gtx-dev-`) enable on-demand translation — as you browse your app in different locales, content is translated in real time. This is useful for prototyping but isn't how production works.

gt-next also works [fully standalone](https://generaltranslation.com/docs/next/concepts/stand-alone) without any API keys — you supply your own translation files and the library handles the rest.

## Locale routing

To serve different languages at different URLs — `/es/about` for Spanish, `/fr/about` for French — you need a dynamic route segment and middleware.

### Create a `[locale]` route segment

Move your pages inside a `[locale]` directory:

<Files>
  <Folder name="app" defaultOpen={true}>
    <Folder name="[locale]" defaultOpen={true}>
      <File name="layout.tsx" />
      <File name="page.tsx" />
      <Folder name="about">
        <File name="page.tsx" />
      </Folder>
      <Folder name="dashboard">
        <File name="page.tsx" />
      </Folder>
    </Folder>
    <Folder name="api">
      <File name="route.ts" />
    </Folder>
  </Folder>
</Files>

### Add middleware

Create a `middleware.ts` (or `proxy.ts` for Next.js 16+) in your project root:

```ts title="middleware.ts" copy
import { createNextMiddleware } from 'gt-next/middleware';

export default createNextMiddleware();

export const config = {
  matcher: ['/((?!api|static|.*\\..*|_next).*)']
};
```

The [middleware](https://generaltranslation.com/docs/next/guides/middleware) handles locale detection automatically — checking the URL for a locale prefix, falling back to a stored cookie, then the browser's `Accept-Language` header, then your `defaultLocale`.

### Update your layout

With the `[locale]` route in place, set the `lang` attribute for SEO and accessibility:

```tsx title="app/[locale]/layout.tsx" copy
import { GTProvider } from 'gt-next';

export default async function LocaleLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: Promise<{ locale: string }>;
}) {
  const { locale } = await params;

  return (
    <html lang={locale}>
      <body>
        <GTProvider>
          {children}
        </GTProvider>
      </body>
    </html>
  );
}
```

### Translate metadata

Page titles and descriptions should be translated too. Use [`getGT`](https://generaltranslation.com/docs/next/api/strings/get-gt) in `generateMetadata`:

```tsx title="app/[locale]/page.tsx" copy
import { getGT } from 'gt-next/server';

export async function generateMetadata() {
  const gt = await getGT();

  return {
    title: gt('Welcome to Our Platform'),
    description: gt('Build multilingual applications with ease.'),
  };
}
```

## Deployment

In production, translations are pre-generated — no on-demand translation, no latency.

1. **Get a production API key** from [dash.generaltranslation.com](https://dash.generaltranslation.com). Production keys start with `gtx-api-` (different from the `gtx-dev-` keys used locally).

2. **Add the translate step to your build:**

```json title="package.json" copy
{
  "scripts": {
    "build": "npx gtx-cli translate && next build"
  }
}
```

The [`translate`](https://generaltranslation.com/docs/cli/translate) command scans your codebase for all `<T>`, `gt()`, and `getGT()` usage, generates translations, and stores them on a CDN. When your app builds, every locale is ready.

That's it — `<html lang>` is set, metadata is translated, content is pre-generated, and routing handles the rest.
